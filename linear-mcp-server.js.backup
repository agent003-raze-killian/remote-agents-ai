#!/usr/bin/env node

import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
} from '@modelcontextprotocol/sdk/types.js';
import { LinearClient } from '@linear/sdk';
import dotenv from 'dotenv';

// Load environment variables
dotenv.config();

class LinearMCPServer {
  constructor() {
    this.server = new Server(
      {
        name: 'linear-mcp-server',
        version: '1.0.0',
      },
      {
        capabilities: {
          tools: {},
        },
      }
    );

    this.linear = new LinearClient({
      apiKey: process.env.LINEAR_API_KEY || 'lin_api_nPk0jYFKGyELDv0Ff6OaxIfjjvRHe7d5RmdZkVt7',
    });

    this.setupToolHandlers();
  }

  setupToolHandlers() {
    this.server.setRequestHandler(ListToolsRequestSchema, async () => {
      return {
        tools: [
          // Issue Management
          {
            name: 'linear_create_issue',
            description: 'Create a new Linear issue',
            inputSchema: {
              type: 'object',
              properties: {
                title: { type: 'string', description: 'Issue title' },
                description: { type: 'string', description: 'Issue description' },
                teamId: { type: 'string', description: 'Team ID' },
                projectId: { type: 'string', description: 'Project ID (optional)' },
                assigneeId: { type: 'string', description: 'Assignee user ID (optional)' },
                priority: { type: 'number', description: 'Priority (0-4, where 4 is urgent)', default: 2 },
                labels: { type: 'array', items: { type: 'string' }, description: 'Label IDs (optional)' },
                stateId: { type: 'string', description: 'Initial state ID (optional)' },
              },
              required: ['title', 'teamId'],
            },
          },
          {
            name: 'linear_get_issue',
            description: 'Get issue details by ID',
            inputSchema: {
              type: 'object',
              properties: {
                issueId: { type: 'string', description: 'Issue ID' },
              },
              required: ['issueId'],
            },
          },
          {
            name: 'linear_update_issue',
            description: 'Update an existing issue',
            inputSchema: {
              type: 'object',
              properties: {
                issueId: { type: 'string', description: 'Issue ID' },
                title: { type: 'string', description: 'New title' },
                description: { type: 'string', description: 'New description' },
                assigneeId: { type: 'string', description: 'Assignee user ID' },
                priority: { type: 'number', description: 'Priority (0-4)' },
                stateId: { type: 'string', description: 'State ID' },
                labels: { type: 'array', items: { type: 'string' }, description: 'Label IDs' },
              },
              required: ['issueId'],
            },
          },
          {
            name: 'linear_list_issues',
            description: 'List issues with filtering options',
            inputSchema: {
              type: 'object',
              properties: {
                teamId: { type: 'string', description: 'Filter by team ID' },
                assigneeId: { type: 'string', description: 'Filter by assignee ID' },
                stateId: { type: 'string', description: 'Filter by state ID' },
                projectId: { type: 'string', description: 'Filter by project ID' },
                labelId: { type: 'string', description: 'Filter by label ID' },
                priority: { type: 'number', description: 'Filter by priority' },
                limit: { type: 'number', description: 'Number of issues to return', default: 50 },
              },
            },
          },
          {
            name: 'linear_search_issues',
            description: 'Search issues by query',
            inputSchema: {
              type: 'object',
              properties: {
                query: { type: 'string', description: 'Search query' },
                limit: { type: 'number', description: 'Number of results', default: 20 },
              },
              required: ['query'],
            },
          },
          {
            name: 'add_issue_comment',
            description: 'Add a comment to an issue',
            inputSchema: {
              type: 'object',
              properties: {
                issueId: { type: 'string', description: 'Issue ID' },
                body: { type: 'string', description: 'Comment body' },
              },
              required: ['issueId', 'body'],
            },
          },

          // Project Management
          {
            name: 'linear_create_project',
            description: 'Create a new project',
            inputSchema: {
              type: 'object',
              properties: {
                name: { type: 'string', description: 'Project name' },
                description: { type: 'string', description: 'Project description' },
                teamId: { type: 'string', description: 'Team ID' },
                color: { type: 'string', description: 'Project color (hex code)' },
                startDate: { type: 'string', description: 'Start date (ISO format)' },
                targetDate: { type: 'string', description: 'Target date (ISO format)' },
              },
              required: ['name', 'teamId'],
            },
          },
          {
            name: 'get_project',
            description: 'Get project details by ID',
            inputSchema: {
              type: 'object',
              properties: {
                projectId: { type: 'string', description: 'Project ID' },
              },
              required: ['projectId'],
            },
          },
          {
            name: 'list_projects',
            description: 'List projects',
            inputSchema: {
              type: 'object',
              properties: {
                teamId: { type: 'string', description: 'Filter by team ID' },
                limit: { type: 'number', description: 'Number of projects to return', default: 50 },
              },
            },
          },
          {
            name: 'update_project',
            description: 'Update project details',
            inputSchema: {
              type: 'object',
              properties: {
                projectId: { type: 'string', description: 'Project ID' },
                name: { type: 'string', description: 'New name' },
                description: { type: 'string', description: 'New description' },
                color: { type: 'string', description: 'New color' },
                startDate: { type: 'string', description: 'New start date' },
                targetDate: { type: 'string', description: 'New target date' },
              },
              required: ['projectId'],
            },
          },

          // Team Management
          {
            name: 'list_teams',
            description: 'List all teams in the workspace',
            inputSchema: {
              type: 'object',
              properties: {
                limit: { type: 'number', description: 'Number of teams to return', default: 50 },
              },
            },
          },
          {
            name: 'get_team',
            description: 'Get team details by ID',
            inputSchema: {
              type: 'object',
              properties: {
                teamId: { type: 'string', description: 'Team ID' },
              },
              required: ['teamId'],
            },
          },
          {
            name: 'get_team_members',
            description: 'Get team members',
            inputSchema: {
              type: 'object',
              properties: {
                teamId: { type: 'string', description: 'Team ID' },
                limit: { type: 'number', description: 'Number of members to return', default: 50 },
              },
              required: ['teamId'],
            },
          },

          // User Management
          {
            name: 'linear_list_users',
            description: 'List all users in the workspace',
            inputSchema: {
              type: 'object',
              properties: {
                limit: { type: 'number', description: 'Number of users to return', default: 50 },
              },
            },
          },
          {
            name: 'linear_get_user',
            description: 'Get user details by ID',
            inputSchema: {
              type: 'object',
              properties: {
                userId: { type: 'string', description: 'User ID' },
              },
              required: ['userId'],
            },
          },
          {
            name: 'get_me',
            description: 'Get current authenticated user details',
            inputSchema: {
              type: 'object',
              properties: {},
            },
          },

          // Label Management
          {
            name: 'create_label',
            description: 'Create a new label',
            inputSchema: {
              type: 'object',
              properties: {
                name: { type: 'string', description: 'Label name' },
                color: { type: 'string', description: 'Label color (hex code)' },
                teamId: { type: 'string', description: 'Team ID' },
                description: { type: 'string', description: 'Label description' },
              },
              required: ['name', 'teamId'],
            },
          },
          {
            name: 'list_labels',
            description: 'List labels',
            inputSchema: {
              type: 'object',
              properties: {
                teamId: { type: 'string', description: 'Filter by team ID' },
                limit: { type: 'number', description: 'Number of labels to return', default: 50 },
              },
            },
          },
          {
            name: 'update_label',
            description: 'Update label details',
            inputSchema: {
              type: 'object',
              properties: {
                labelId: { type: 'string', description: 'Label ID' },
                name: { type: 'string', description: 'New name' },
                color: { type: 'string', description: 'New color' },
                description: { type: 'string', description: 'New description' },
              },
              required: ['labelId'],
            },
          },

          // Workflow State Management
          {
            name: 'list_workflow_states',
            description: 'List workflow states for a team',
            inputSchema: {
              type: 'object',
              properties: {
                teamId: { type: 'string', description: 'Team ID' },
                limit: { type: 'number', description: 'Number of states to return', default: 50 },
              },
              required: ['teamId'],
            },
          },
          {
            name: 'get_workflow_state',
            description: 'Get workflow state details by ID',
            inputSchema: {
              type: 'object',
              properties: {
                stateId: { type: 'string', description: 'State ID' },
              },
              required: ['stateId'],
            },
          },

          // Workspace Information
          {
            name: 'get_workspace',
            description: 'Get workspace information',
            inputSchema: {
              type: 'object',
              properties: {},
            },
          },
        ],
      };
    });

    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
      const { name, arguments: args } = request.params;

      try {
        switch (name) {
          // Issue Management
          case 'linear_create_issue':
            return await this.createIssue(args);
          case 'linear_get_issue':
            return await this.getIssue(args);
          case 'linear_update_issue':
            return await this.updateIssue(args);
          case 'linear_list_issues':
            return await this.listIssues(args);
          case 'linear_search_issues':
            return await this.searchIssues(args);
          case 'add_issue_comment':
            return await this.addIssueComment(args);

          // Project Management
          case 'linear_create_project':
            return await this.createProject(args);
          case 'get_project':
            return await this.getProject(args);
          case 'list_projects':
            return await this.listProjects(args);
          case 'update_project':
            return await this.updateProject(args);

          // Team Management
          case 'list_teams':
            return await this.listTeams(args);
          case 'get_team':
            return await this.getTeam(args);
          case 'get_team_members':
            return await this.getTeamMembers(args);

          // User Management
          case 'linear_list_users':
            return await this.listUsers(args);
          case 'linear_get_user':
            return await this.getUser(args);
          case 'get_me':
            return await this.getMe(args);

          // Label Management
          case 'create_label':
            return await this.createLabel(args);
          case 'list_labels':
            return await this.listLabels(args);
          case 'update_label':
            return await this.updateLabel(args);

          // Workflow State Management
          case 'list_workflow_states':
            return await this.listWorkflowStates(args);
          case 'get_workflow_state':
            return await this.getWorkflowState(args);

          // Workspace Information
          case 'get_workspace':
            return await this.getWorkspace(args);

          default:
            throw new Error(`Unknown tool: ${name}`);
        }
      } catch (error) {
        return {
          content: [
            {
              type: 'text',
              text: `Error executing ${name}: ${error.message}`,
            },
          ],
        };
      }
    });
  }

  // Issue Management Methods
  async createIssue(args) {
    const { title, description, teamId, projectId, assigneeId, priority = 2, labels, stateId } = args;
    
    // Convert team key to UUID if needed
    let actualTeamId = teamId;
    if (teamId && teamId.length <= 5) {
      // This looks like a team key, need to get the UUID
      const teams = await this.linear.teams({ first: 50 });
      const team = teams.nodes.find(t => t.key === teamId);
      if (team) {
        actualTeamId = team.id;
      }
    }
    
    const issueData = {
      title,
      teamId: actualTeamId,
      priority,
    };
    
    if (description) issueData.description = description;
    if (projectId) issueData.projectId = projectId;
    if (assigneeId) issueData.assigneeId = assigneeId;
    if (labels) issueData.labelIds = labels;
    if (stateId) issueData.stateId = stateId;
    
    const issue = await this.linear.client.request(`
      mutation IssueCreate($input: IssueCreateInput!) {
        issueCreate(input: $input) {
          success
          issue {
            id
            title
            description
            url
          }
        }
      }
    `, {
      input: issueData
    });
    
    return {
      content: [
        {
          type: 'text',
          text: `Issue created successfully!\nTitle: ${title}\nID: ${issue.data.issueCreate.issue.id}\nURL: ${issue.data.issueCreate.issue.url}`,
        },
      ],
    };
  }

  async getIssue(args) {
    const { issueId } = args;
    const issue = await this.linear.issue(issueId);
    
    return {
      content: [
        {
          type: 'text',
          text: `Issue: ${issue.title}\nDescription: ${issue.description || 'No description'}\nState: ${issue.state?.name || 'Unknown'}\nAssignee: ${issue.assignee?.name || 'Unassigned'}\nPriority: ${issue.priority}\nURL: ${issue.url}`,
        },
      ],
    };
  }

  async updateIssue(args) {
    const { issueId, title, description, assigneeId, priority, stateId, labels } = args;
    
    const updateData = { id: issueId };
    if (title) updateData.title = title;
    if (description) updateData.description = description;
    if (assigneeId) updateData.assigneeId = assigneeId;
    if (priority !== undefined) updateData.priority = priority;
    if (stateId) updateData.stateId = stateId;
    if (labels) updateData.labelIds = labels;
    
    const issue = await this.linear.issueUpdate(updateData);
    
    return {
      content: [
        {
          type: 'text',
          text: `Issue updated successfully!\nTitle: ${issue.issue.title}\nURL: ${issue.issue.url}`,
        },
      ],
    };
  }

  async listIssues(args) {
    const { teamId, assigneeId, stateId, projectId, labelId, priority, limit = 50 } = args;
    
    const filter = {};
    if (teamId) filter.team = { id: { eq: teamId } };
    if (assigneeId) filter.assignee = { id: { eq: assigneeId } };
    if (stateId) filter.state = { id: { eq: stateId } };
    if (projectId) filter.project = { id: { eq: projectId } };
    if (labelId) filter.labels = { id: { eq: labelId } };
    if (priority !== undefined) filter.priority = { eq: priority };
    
    const issues = await this.linear.issues({
      filter,
      first: limit,
    });
    
    const issueList = issues.nodes.map(issue => 
      `• ${issue.title} (${issue.state?.name || 'Unknown'}) - ${issue.assignee?.name || 'Unassigned'}`
    ).join('\n');
    
    return {
      content: [
        {
          type: 'text',
          text: `Found ${issues.nodes.length} issues:\n${issueList}`,
        },
      ],
    };
  }

  async searchIssues(args) {
    const { query, limit = 20 } = args;
    
    const issues = await this.linear.issueSearch({
      query,
      first: limit,
    });
    
    const issueList = issues.nodes.map(issue => 
      `• ${issue.title} (${issue.state?.name || 'Unknown'}) - ${issue.assignee?.name || 'Unassigned'}`
    ).join('\n');
    
    return {
      content: [
        {
          type: 'text',
          text: `Found ${issues.nodes.length} issues for query "${query}":\n${issueList}`,
        },
      ],
    };
  }

  async addIssueComment(args) {
    const { issueId, body } = args;
    
    const comment = await this.linear.commentCreate({
      issueId,
      body,
    });
    
    return {
      content: [
        {
          type: 'text',
          text: `Comment added successfully to issue ${issueId}!`,
        },
      ],
    };
  }

  // Project Management Methods
  async createProject(args) {
    const { name, description, teamId, color, startDate, targetDate } = args;
    
    const projectData = {
      name,
      teamIds: [teamId],
    };
    
    if (description) projectData.description = description;
    if (color) projectData.color = color;
    if (startDate) projectData.startDate = startDate;
    if (targetDate) projectData.targetDate = targetDate;
    
    const project = await this.linear.projectCreate(projectData);
    
    return {
      content: [
        {
          type: 'text',
          text: `Project created successfully!\nName: ${name}\nID: ${project.project.id}\nURL: ${project.project.url}`,
        },
      ],
    };
  }

  async getProject(args) {
    const { projectId } = args;
    const project = await this.linear.project(projectId);
    
    return {
      content: [
        {
          type: 'text',
          text: `Project: ${project.name}\nDescription: ${project.description || 'No description'}\nStatus: ${project.state}\nURL: ${project.url}`,
        },
      ],
    };
  }

  async listProjects(args) {
    const { teamId, limit = 50 } = args;
    
    const filter = {};
    if (teamId) filter.team = { id: { eq: teamId } };
    
    const projects = await this.linear.projects({
      filter,
      first: limit,
    });
    
    const projectList = projects.nodes.map(project => 
      `• ${project.name} (${project.state})`
    ).join('\n');
    
    return {
      content: [
        {
          type: 'text',
          text: `Found ${projects.nodes.length} projects:\n${projectList}`,
        },
      ],
    };
  }

  async updateProject(args) {
    const { projectId, name, description, color, startDate, targetDate } = args;
    
    const updateData = { id: projectId };
    if (name) updateData.name = name;
    if (description) updateData.description = description;
    if (color) updateData.color = color;
    if (startDate) updateData.startDate = startDate;
    if (targetDate) updateData.targetDate = targetDate;
    
    const project = await this.linear.projectUpdate(updateData);
    
    return {
      content: [
        {
          type: 'text',
          text: `Project updated successfully!\nName: ${project.project.name}\nURL: ${project.project.url}`,
        },
      ],
    };
  }

  // Team Management Methods
  async listTeams(args) {
    const { limit = 50 } = args;
    
    const teams = await this.linear.teams({
      first: limit,
    });
    
    const teamList = teams.nodes.map(team => 
      `• ${team.name} (${team.key}) - ${team.description || 'No description'}`
    ).join('\n');
    
    return {
      content: [
        {
          type: 'text',
          text: `Found ${teams.nodes.length} teams:\n${teamList}`,
        },
      ],
    };
  }

  async getTeam(args) {
    const { teamId } = args;
    const team = await this.linear.team(teamId);
    
    return {
      content: [
        {
          type: 'text',
          text: `Team: ${team.name}\nKey: ${team.key}\nDescription: ${team.description || 'No description'}`,
        },
      ],
    };
  }

  async getTeamMembers(args) {
    const { teamId, limit = 50 } = args;
    
    const team = await this.linear.team(teamId);
    const members = await team.members({
      first: limit,
    });
    
    const memberList = members.nodes.map(member => 
      `• ${member.name} (${member.email})`
    ).join('\n');
    
    return {
      content: [
        {
          type: 'text',
          text: `Found ${members.nodes.length} team members:\n${memberList}`,
        },
      ],
    };
  }

  // User Management Methods
  async listUsers(args) {
    const { limit = 50 } = args;
    
    const users = await this.linear.users({
      first: limit,
    });
    
    const userList = users.nodes.map(user => 
      `• ${user.name} (${user.email}) - ${user.displayName || 'No display name'}`
    ).join('\n');
    
    return {
      content: [
        {
          type: 'text',
          text: `Found ${users.nodes.length} users:\n${userList}`,
        },
      ],
    };
  }

  async getUser(args) {
    const { userId } = args;
    const user = await this.linear.user(userId);
    
    return {
      content: [
        {
          type: 'text',
          text: `User: ${user.name}\nEmail: ${user.email}\nDisplay Name: ${user.displayName || 'No display name'}`,
        },
      ],
    };
  }

  async getMe(args) {
    const viewer = await this.linear.viewer;
    
    return {
      content: [
        {
          type: 'text',
          text: `Authenticated User: ${viewer.name}\nEmail: ${viewer.email}\nDisplay Name: ${viewer.displayName || 'No display name'}`,
        },
      ],
    };
  }

  // Label Management Methods
  async createLabel(args) {
    const { name, color, teamId, description } = args;
    
    const labelData = {
      name,
      teamId,
    };
    
    if (color) labelData.color = color;
    if (description) labelData.description = description;
    
    const label = await this.linear.labelCreate(labelData);
    
    return {
      content: [
        {
          type: 'text',
          text: `Label created successfully!\nName: ${name}\nID: ${label.label.id}`,
        },
      ],
    };
  }

  async listLabels(args) {
    const { teamId, limit = 50 } = args;
    
    const filter = {};
    if (teamId) filter.team = { id: { eq: teamId } };
    
    const labels = await this.linear.labels({
      filter,
      first: limit,
    });
    
    const labelList = labels.nodes.map(label => 
      `• ${label.name} (${label.color || 'No color'})`
    ).join('\n');
    
    return {
      content: [
        {
          type: 'text',
          text: `Found ${labels.nodes.length} labels:\n${labelList}`,
        },
      ],
    };
  }

  async updateLabel(args) {
    const { labelId, name, color, description } = args;
    
    const updateData = { id: labelId };
    if (name) updateData.name = name;
    if (color) updateData.color = color;
    if (description) updateData.description = description;
    
    const label = await this.linear.labelUpdate(updateData);
    
    return {
      content: [
        {
          type: 'text',
          text: `Label updated successfully!\nName: ${label.label.name}`,
        },
      ],
    };
  }

  // Workflow State Management Methods
  async listWorkflowStates(args) {
    const { teamId, limit = 50 } = args;
    
    const team = await this.linear.team(teamId);
    const states = await team.states({
      first: limit,
    });
    
    const stateList = states.nodes.map(state => 
      `• ${state.name} (${state.type}) - ${state.description || 'No description'}`
    ).join('\n');
    
    return {
      content: [
        {
          type: 'text',
          text: `Found ${states.nodes.length} workflow states:\n${stateList}`,
        },
      ],
    };
  }

  async getWorkflowState(args) {
    const { stateId } = args;
    const state = await this.linear.workflowState(stateId);
    
    return {
      content: [
        {
          type: 'text',
          text: `Workflow State: ${state.name}\nType: ${state.type}\nDescription: ${state.description || 'No description'}`,
        },
      ],
    };
  }

  // Workspace Information Methods
  async getWorkspace(args) {
    const workspace = await this.linear.organization;
    
    return {
      content: [
        {
          type: 'text',
          text: `Workspace: ${workspace.name}\nURL: ${workspace.url}\nDescription: ${workspace.description || 'No description'}`,
        },
      ],
    };
  }

  async run() {
    const transport = new StdioServerTransport();
    await this.server.connect(transport);
    console.error('Linear MCP server running on stdio');
  }
}

const server = new LinearMCPServer();
server.run().catch(console.error);


