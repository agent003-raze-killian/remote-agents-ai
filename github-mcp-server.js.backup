#!/usr/bin/env node

import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
} from '@modelcontextprotocol/sdk/types.js';
import { Octokit } from '@octokit/rest';
import dotenv from 'dotenv';

// Load environment variables
dotenv.config();

class GitHubMCPServer {
  constructor() {
    this.server = new Server(
      {
        name: 'github-mcp-server',
        version: '1.0.0',
      },
      {
        capabilities: {
          tools: {},
        },
      }
    );

    this.octokit = new Octokit({
      auth: process.env.GITHUB_TOKEN,
    });

    this.setupToolHandlers();
  }

  setupToolHandlers() {
    this.server.setRequestHandler(ListToolsRequestSchema, async () => {
      return {
        tools: [
          // Repository Management
          {
            name: 'create_repository',
            description: 'Create a new GitHub repository',
            inputSchema: {
              type: 'object',
              properties: {
                name: { type: 'string', description: 'Repository name' },
                description: { type: 'string', description: 'Repository description' },
                private: { type: 'boolean', description: 'Make repository private' },
                autoInit: { type: 'boolean', description: 'Initialize with README' },
              },
              required: ['name'],
            },
          },
          {
            name: 'get_repository',
            description: 'Get repository information',
            inputSchema: {
              type: 'object',
              properties: {
                owner: { type: 'string', description: 'Repository owner' },
                repo: { type: 'string', description: 'Repository name' },
              },
              required: ['owner', 'repo'],
            },
          },
          {
            name: 'list_repositories',
            description: 'List repositories for authenticated user',
            inputSchema: {
              type: 'object',
              properties: {
                type: { type: 'string', enum: ['all', 'owner', 'public', 'private', 'member'], default: 'all' },
                sort: { type: 'string', enum: ['created', 'updated', 'pushed', 'full_name'], default: 'updated' },
                per_page: { type: 'number', default: 30 },
              },
            },
          },
          {
            name: 'delete_repository',
            description: 'Delete a repository',
            inputSchema: {
              type: 'object',
              properties: {
                owner: { type: 'string', description: 'Repository owner' },
                repo: { type: 'string', description: 'Repository name' },
              },
              required: ['owner', 'repo'],
            },
          },
          {
            name: 'fork_repository',
            description: 'Fork a repository',
            inputSchema: {
              type: 'object',
              properties: {
                owner: { type: 'string', description: 'Repository owner' },
                repo: { type: 'string', description: 'Repository name' },
                organization: { type: 'string', description: 'Organization to fork to' },
              },
              required: ['owner', 'repo'],
            },
          },

          // Issues Management
          {
            name: 'create_issue',
            description: 'Create a new issue',
            inputSchema: {
              type: 'object',
              properties: {
                owner: { type: 'string', description: 'Repository owner' },
                repo: { type: 'string', description: 'Repository name' },
                title: { type: 'string', description: 'Issue title' },
                body: { type: 'string', description: 'Issue body' },
                labels: { type: 'array', items: { type: 'string' }, description: 'Issue labels' },
                assignees: { type: 'array', items: { type: 'string' }, description: 'Issue assignees' },
              },
              required: ['owner', 'repo', 'title'],
            },
          },
          {
            name: 'list_issues',
            description: 'List issues in a repository',
            inputSchema: {
              type: 'object',
              properties: {
                owner: { type: 'string', description: 'Repository owner' },
                repo: { type: 'string', description: 'Repository name' },
                state: { type: 'string', enum: ['open', 'closed', 'all'], default: 'open' },
                labels: { type: 'string', description: 'Filter by labels' },
                assignee: { type: 'string', description: 'Filter by assignee' },
                per_page: { type: 'number', default: 30 },
              },
              required: ['owner', 'repo'],
            },
          },
          {
            name: 'update_issue',
            description: 'Update an issue',
            inputSchema: {
              type: 'object',
              properties: {
                owner: { type: 'string', description: 'Repository owner' },
                repo: { type: 'string', description: 'Repository name' },
                issue_number: { type: 'number', description: 'Issue number' },
                title: { type: 'string', description: 'New issue title' },
                body: { type: 'string', description: 'New issue body' },
                state: { type: 'string', enum: ['open', 'closed'] },
                labels: { type: 'array', items: { type: 'string' }, description: 'Issue labels' },
                assignees: { type: 'array', items: { type: 'string' }, description: 'Issue assignees' },
              },
              required: ['owner', 'repo', 'issue_number'],
            },
          },

          // Pull Requests Management
          {
            name: 'create_pull_request',
            description: 'Create a new pull request',
            inputSchema: {
              type: 'object',
              properties: {
                owner: { type: 'string', description: 'Repository owner' },
                repo: { type: 'string', description: 'Repository name' },
                title: { type: 'string', description: 'Pull request title' },
                head: { type: 'string', description: 'Source branch' },
                base: { type: 'string', description: 'Target branch', default: 'main' },
                body: { type: 'string', description: 'Pull request body' },
                draft: { type: 'boolean', description: 'Create as draft', default: false },
              },
              required: ['owner', 'repo', 'title', 'head'],
            },
          },
          {
            name: 'list_pull_requests',
            description: 'List pull requests in a repository',
            inputSchema: {
              type: 'object',
              properties: {
                owner: { type: 'string', description: 'Repository owner' },
                repo: { type: 'string', description: 'Repository name' },
                state: { type: 'string', enum: ['open', 'closed', 'all'], default: 'open' },
                head: { type: 'string', description: 'Filter by source branch' },
                base: { type: 'string', description: 'Filter by target branch' },
                per_page: { type: 'number', default: 30 },
              },
              required: ['owner', 'repo'],
            },
          },
          {
            name: 'merge_pull_request',
            description: 'Merge a pull request',
            inputSchema: {
              type: 'object',
              properties: {
                owner: { type: 'string', description: 'Repository owner' },
                repo: { type: 'string', description: 'Repository name' },
                pull_number: { type: 'number', description: 'Pull request number' },
                merge_method: { type: 'string', enum: ['merge', 'squash', 'rebase'], default: 'merge' },
                commit_title: { type: 'string', description: 'Custom commit title' },
                commit_message: { type: 'string', description: 'Custom commit message' },
              },
              required: ['owner', 'repo', 'pull_number'],
            },
          },

          // File Management
          {
            name: 'get_file_contents',
            description: 'Get contents of a file from repository',
            inputSchema: {
              type: 'object',
              properties: {
                owner: { type: 'string', description: 'Repository owner' },
                repo: { type: 'string', description: 'Repository name' },
                path: { type: 'string', description: 'File path' },
                ref: { type: 'string', description: 'Branch or commit SHA', default: 'main' },
              },
              required: ['owner', 'repo', 'path'],
            },
          },
          {
            name: 'create_or_update_file',
            description: 'Create or update a file in repository',
            inputSchema: {
              type: 'object',
              properties: {
                owner: { type: 'string', description: 'Repository owner' },
                repo: { type: 'string', description: 'Repository name' },
                path: { type: 'string', description: 'File path' },
                message: { type: 'string', description: 'Commit message' },
                content: { type: 'string', description: 'File content (base64 encoded)' },
                branch: { type: 'string', description: 'Branch name', default: 'main' },
                sha: { type: 'string', description: 'SHA of file to update (for updates)' },
              },
              required: ['owner', 'repo', 'path', 'message', 'content'],
            },
          },
          {
            name: 'delete_file',
            description: 'Delete a file from repository',
            inputSchema: {
              type: 'object',
              properties: {
                owner: { type: 'string', description: 'Repository owner' },
                repo: { type: 'string', description: 'Repository name' },
                path: { type: 'string', description: 'File path' },
                message: { type: 'string', description: 'Commit message' },
                branch: { type: 'string', description: 'Branch name', default: 'main' },
                sha: { type: 'string', description: 'SHA of file to delete' },
              },
              required: ['owner', 'repo', 'path', 'message', 'sha'],
            },
          },

          // Branch Management
          {
            name: 'create_branch',
            description: 'Create a new branch',
            inputSchema: {
              type: 'object',
              properties: {
                owner: { type: 'string', description: 'Repository owner' },
                repo: { type: 'string', description: 'Repository name' },
                branch: { type: 'string', description: 'New branch name' },
                from_branch: { type: 'string', description: 'Source branch', default: 'main' },
              },
              required: ['owner', 'repo', 'branch'],
            },
          },
          {
            name: 'list_branches',
            description: 'List branches in a repository',
            inputSchema: {
              type: 'object',
              properties: {
                owner: { type: 'string', description: 'Repository owner' },
                repo: { type: 'string', description: 'Repository name' },
                protected: { type: 'boolean', description: 'Filter by protected status' },
                per_page: { type: 'number', default: 30 },
              },
              required: ['owner', 'repo'],
            },
          },
          {
            name: 'delete_branch',
            description: 'Delete a branch',
            inputSchema: {
              type: 'object',
              properties: {
                owner: { type: 'string', description: 'Repository owner' },
                repo: { type: 'string', description: 'Repository name' },
                branch: { type: 'string', description: 'Branch name to delete' },
              },
              required: ['owner', 'repo', 'branch'],
            },
          },

          // Collaborators Management
          {
            name: 'add_collaborator',
            description: 'Add a collaborator to repository',
            inputSchema: {
              type: 'object',
              properties: {
                owner: { type: 'string', description: 'Repository owner' },
                repo: { type: 'string', description: 'Repository name' },
                username: { type: 'string', description: 'Username to add' },
                permission: { type: 'string', enum: ['pull', 'push', 'admin', 'maintain', 'triage'], default: 'push' },
              },
              required: ['owner', 'repo', 'username'],
            },
          },
          {
            name: 'list_collaborators',
            description: 'List collaborators in a repository',
            inputSchema: {
              type: 'object',
              properties: {
                owner: { type: 'string', description: 'Repository owner' },
                repo: { type: 'string', description: 'Repository name' },
                affiliation: { type: 'string', enum: ['outside', 'direct', 'all'], default: 'all' },
                per_page: { type: 'number', default: 30 },
              },
              required: ['owner', 'repo'],
            },
          },
          {
            name: 'remove_collaborator',
            description: 'Remove a collaborator from repository',
            inputSchema: {
              type: 'object',
              properties: {
                owner: { type: 'string', description: 'Repository owner' },
                repo: { type: 'string', description: 'Repository name' },
                username: { type: 'string', description: 'Username to remove' },
              },
              required: ['owner', 'repo', 'username'],
            },
          },

          // Releases Management
          {
            name: 'create_release',
            description: 'Create a new release',
            inputSchema: {
              type: 'object',
              properties: {
                owner: { type: 'string', description: 'Repository owner' },
                repo: { type: 'string', description: 'Repository name' },
                tag_name: { type: 'string', description: 'Release tag' },
                target_commitish: { type: 'string', description: 'Target branch or commit', default: 'main' },
                name: { type: 'string', description: 'Release name' },
                body: { type: 'string', description: 'Release notes' },
                draft: { type: 'boolean', description: 'Create as draft', default: false },
                prerelease: { type: 'boolean', description: 'Mark as prerelease', default: false },
              },
              required: ['owner', 'repo', 'tag_name'],
            },
          },
          {
            name: 'list_releases',
            description: 'List releases in a repository',
            inputSchema: {
              type: 'object',
              properties: {
                owner: { type: 'string', description: 'Repository owner' },
                repo: { type: 'string', description: 'Repository name' },
                per_page: { type: 'number', default: 30 },
              },
              required: ['owner', 'repo'],
            },
          },

          // Search
          {
            name: 'search_repositories',
            description: 'Search for repositories',
            inputSchema: {
              type: 'object',
              properties: {
                query: { type: 'string', description: 'Search query' },
                sort: { type: 'string', enum: ['stars', 'forks', 'help-wanted-issues', 'updated'], default: 'stars' },
                order: { type: 'string', enum: ['desc', 'asc'], default: 'desc' },
                per_page: { type: 'number', default: 30 },
              },
              required: ['query'],
            },
          },
          {
            name: 'search_issues',
            description: 'Search for issues',
            inputSchema: {
              type: 'object',
              properties: {
                query: { type: 'string', description: 'Search query' },
                sort: { type: 'string', enum: ['comments', 'reactions', 'interactions', 'created', 'updated'], default: 'created' },
                order: { type: 'string', enum: ['desc', 'asc'], default: 'desc' },
                per_page: { type: 'number', default: 30 },
              },
              required: ['query'],
            },
          },
          {
            name: 'search_code',
            description: 'Search for code',
            inputSchema: {
              type: 'object',
              properties: {
                query: { type: 'string', description: 'Search query' },
                sort: { type: 'string', enum: ['indexed'], default: 'indexed' },
                order: { type: 'string', enum: ['desc', 'asc'], default: 'desc' },
                per_page: { type: 'number', default: 30 },
              },
              required: ['query'],
            },
          },

          // User Management
          {
            name: 'get_user',
            description: 'Get user information',
            inputSchema: {
              type: 'object',
              properties: {
                username: { type: 'string', description: 'Username to get info for' },
              },
            },
          },
          {
            name: 'get_authenticated_user',
            description: 'Get authenticated user information',
            inputSchema: {
              type: 'object',
              properties: {},
            },
          },
        ],
      };
    });

    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
      const { name, arguments: args } = request.params;

      try {
        switch (name) {
          // Repository Management
          case 'create_repository':
            return await this.createRepository(args);
          case 'get_repository':
            return await this.getRepository(args);
          case 'list_repositories':
            return await this.listRepositories(args);
          case 'delete_repository':
            return await this.deleteRepository(args);
          case 'fork_repository':
            return await this.forkRepository(args);

          // Issues Management
          case 'create_issue':
            return await this.createIssue(args);
          case 'list_issues':
            return await this.listIssues(args);
          case 'update_issue':
            return await this.updateIssue(args);

          // Pull Requests Management
          case 'create_pull_request':
            return await this.createPullRequest(args);
          case 'list_pull_requests':
            return await this.listPullRequests(args);
          case 'merge_pull_request':
            return await this.mergePullRequest(args);

          // File Management
          case 'get_file_contents':
            return await this.getFileContents(args);
          case 'create_or_update_file':
            return await this.createOrUpdateFile(args);
          case 'delete_file':
            return await this.deleteFile(args);

          // Branch Management
          case 'create_branch':
            return await this.createBranch(args);
          case 'list_branches':
            return await this.listBranches(args);
          case 'delete_branch':
            return await this.deleteBranch(args);

          // Collaborators Management
          case 'add_collaborator':
            return await this.addCollaborator(args);
          case 'list_collaborators':
            return await this.listCollaborators(args);
          case 'remove_collaborator':
            return await this.removeCollaborator(args);

          // Releases Management
          case 'create_release':
            return await this.createRelease(args);
          case 'list_releases':
            return await this.listReleases(args);

          // Search
          case 'search_repositories':
            return await this.searchRepositories(args);
          case 'search_issues':
            return await this.searchIssues(args);
          case 'search_code':
            return await this.searchCode(args);

          // User Management
          case 'get_user':
            return await this.getUser(args);
          case 'get_authenticated_user':
            return await this.getAuthenticatedUser(args);

          default:
            throw new Error(`Unknown tool: ${name}`);
        }
      } catch (error) {
        return {
          content: [
            {
              type: 'text',
              text: `Error executing ${name}: ${error.message}`,
            },
          ],
        };
      }
    });
  }

  // Repository Management Methods
  async createRepository(args) {
    const { name, description, private: isPrivate = false, autoInit = false } = args;
    const response = await this.octokit.rest.repos.createForAuthenticatedUser({
      name,
      description,
      private: isPrivate,
      auto_init: autoInit,
    });
    return {
      content: [
        {
          type: 'text',
          text: `Repository "${name}" created successfully!\nURL: ${response.data.html_url}`,
        },
      ],
    };
  }

  async getRepository(args) {
    const { owner, repo } = args;
    const response = await this.octokit.rest.repos.get({ owner, repo });
    return {
      content: [
        {
          type: 'text',
          text: `Repository: ${response.data.full_name}\nDescription: ${response.data.description || 'No description'}\nStars: ${response.data.stargazers_count}\nForks: ${response.data.forks_count}\nURL: ${response.data.html_url}`,
        },
      ],
    };
  }

  async listRepositories(args) {
    const { type = 'all', sort = 'updated', per_page = 30 } = args;
    const response = await this.octokit.rest.repos.listForAuthenticatedUser({
      type,
      sort,
      per_page,
    });
    
    const repos = response.data.map(repo => 
      `â€¢ ${repo.full_name} (${repo.private ? 'Private' : 'Public'}) - ${repo.stargazers_count} stars`
    ).join('\n');
    
    return {
      content: [
        {
          type: 'text',
          text: `Found ${response.data.length} repositories:\n${repos}`,
        },
      ],
    };
  }

  async deleteRepository(args) {
    const { owner, repo } = args;
    await this.octokit.rest.repos.delete({ owner, repo });
    return {
      content: [
        {
          type: 'text',
          text: `Repository "${owner}/${repo}" deleted successfully.`,
        },
      ],
    };
  }

  async forkRepository(args) {
    const { owner, repo, organization } = args;
    const forkOptions = { owner, repo };
    if (organization) {
      forkOptions.organization = organization;
    }
    
    const response = await this.octokit.rest.repos.createFork(forkOptions);
    return {
      content: [
        {
          type: 'text',
          text: `Repository forked successfully!\nFork URL: ${response.data.html_url}`,
        },
      ],
    };
  }

  // Issues Management Methods
  async createIssue(args) {
    const { owner, repo, title, body, labels, assignees } = args;
    const issueData = { owner, repo, title };
    
    if (body) issueData.body = body;
    if (labels) issueData.labels = labels;
    if (assignees) issueData.assignees = assignees;
    
    const response = await this.octokit.rest.issues.create(issueData);
    return {
      content: [
        {
          type: 'text',
          text: `Issue created successfully!\nTitle: ${title}\nNumber: #${response.data.number}\nURL: ${response.data.html_url}`,
        },
      ],
    };
  }

  async listIssues(args) {
    const { owner, repo, state = 'open', labels, assignee, per_page = 30 } = args;
    const issueParams = { owner, repo, state, per_page };
    
    if (labels) issueParams.labels = labels;
    if (assignee) issueParams.assignee = assignee;
    
    const response = await this.octokit.rest.issues.listForRepo(issueParams);
    
    const issues = response.data.map(issue => 
      `â€¢ #${issue.number}: ${issue.title} (${issue.state}) - ${issue.user.login}`
    ).join('\n');
    
    return {
      content: [
        {
          type: 'text',
          text: `Found ${response.data.length} issues:\n${issues}`,
        },
      ],
    };
  }

  async updateIssue(args) {
    const { owner, repo, issue_number, title, body, state, labels, assignees } = args;
    const updateData = { owner, repo, issue_number };
    
    if (title) updateData.title = title;
    if (body) updateData.body = body;
    if (state) updateData.state = state;
    if (labels) updateData.labels = labels;
    if (assignees) updateData.assignees = assignees;
    
    const response = await this.octokit.rest.issues.update(updateData);
    return {
      content: [
        {
          type: 'text',
          text: `Issue #${issue_number} updated successfully!\nURL: ${response.data.html_url}`,
        },
      ],
    };
  }

  // Pull Requests Management Methods
  async createPullRequest(args) {
    const { owner, repo, title, head, base = 'main', body, draft = false } = args;
    const response = await this.octokit.rest.pulls.create({
      owner,
      repo,
      title,
      head,
      base,
      body,
      draft,
    });
    return {
      content: [
        {
          type: 'text',
          text: `Pull request created successfully!\nTitle: ${title}\nNumber: #${response.data.number}\nURL: ${response.data.html_url}`,
        },
      ],
    };
  }

  async listPullRequests(args) {
    const { owner, repo, state = 'open', head, base, per_page = 30 } = args;
    const prParams = { owner, repo, state, per_page };
    
    if (head) prParams.head = head;
    if (base) prParams.base = base;
    
    const response = await this.octokit.rest.pulls.list(prParams);
    
    const prs = response.data.map(pr => 
      `â€¢ #${pr.number}: ${pr.title} (${pr.state}) - ${pr.user.login}`
    ).join('\n');
    
    return {
      content: [
        {
          type: 'text',
          text: `Found ${response.data.length} pull requests:\n${prs}`,
        },
      ],
    };
  }

  async mergePullRequest(args) {
    const { owner, repo, pull_number, merge_method = 'merge', commit_title, commit_message } = args;
    const mergeData = { owner, repo, pull_number, merge_method };
    
    if (commit_title) mergeData.commit_title = commit_title;
    if (commit_message) mergeData.commit_message = commit_message;
    
    const response = await this.octokit.rest.pulls.merge(mergeData);
    return {
      content: [
        {
          type: 'text',
          text: `Pull request #${pull_number} merged successfully!\nMerge SHA: ${response.data.sha}`,
        },
      ],
    };
  }

  // File Management Methods
  async getFileContents(args) {
    const { owner, repo, path, ref = 'main' } = args;
    const response = await this.octokit.rest.repos.getContent({
      owner,
      repo,
      path,
      ref,
    });
    
    if (Array.isArray(response.data)) {
      // Directory listing
      const files = response.data.map(item => 
        `${item.type === 'dir' ? 'ðŸ“' : 'ðŸ“„'} ${item.name}`
      ).join('\n');
      return {
        content: [
          {
            type: 'text',
            text: `Directory contents for ${path}:\n${files}`,
          },
        ],
      };
    } else {
      // File content
      const content = Buffer.from(response.data.content, 'base64').toString('utf-8');
      return {
        content: [
          {
            type: 'text',
            text: `File: ${path}\n\n${content}`,
          },
        ],
      };
    }
  }

  async createOrUpdateFile(args) {
    const { owner, repo, path, message, content, branch = 'main', sha } = args;
    const fileData = {
      owner,
      repo,
      path,
      message,
      content: Buffer.from(content).toString('base64'),
      branch,
    };
    
    if (sha) fileData.sha = sha; // For updates
    
    const response = await this.octokit.rest.repos.createOrUpdateFileContents(fileData);
    return {
      content: [
        {
          type: 'text',
          text: `File ${sha ? 'updated' : 'created'} successfully!\nPath: ${path}\nCommit SHA: ${response.data.commit.sha}`,
        },
      ],
    };
  }

  async deleteFile(args) {
    const { owner, repo, path, message, branch = 'main', sha } = args;
    const response = await this.octokit.rest.repos.deleteFile({
      owner,
      repo,
      path,
      message,
      branch,
      sha,
    });
    return {
      content: [
        {
          type: 'text',
          text: `File deleted successfully!\nPath: ${path}\nCommit SHA: ${response.data.commit.sha}`,
        },
      ],
    };
  }

  // Branch Management Methods
  async createBranch(args) {
    const { owner, repo, branch, from_branch = 'main' } = args;
    
    // Get the SHA of the source branch
    const sourceRef = await this.octokit.rest.git.getRef({
      owner,
      repo,
      ref: `heads/${from_branch}`,
    });
    
    const response = await this.octokit.rest.git.createRef({
      owner,
      repo,
      ref: `refs/heads/${branch}`,
      sha: sourceRef.data.object.sha,
    });
    
    return {
      content: [
        {
          type: 'text',
          text: `Branch "${branch}" created successfully from "${from_branch}"!`,
        },
      ],
    };
  }

  async listBranches(args) {
    const { owner, repo, protected: isProtected, per_page = 30 } = args;
    const branchParams = { owner, repo, per_page };
    
    if (isProtected !== undefined) branchParams.protected = isProtected;
    
    const response = await this.octokit.rest.repos.listBranches(branchParams);
    
    const branches = response.data.map(branch => 
      `â€¢ ${branch.name}${branch.protected ? ' (Protected)' : ''}`
    ).join('\n');
    
    return {
      content: [
        {
          type: 'text',
          text: `Found ${response.data.length} branches:\n${branches}`,
        },
      ],
    };
  }

  async deleteBranch(args) {
    const { owner, repo, branch } = args;
    await this.octokit.rest.git.deleteRef({
      owner,
      repo,
      ref: `heads/${branch}`,
    });
    return {
      content: [
        {
          type: 'text',
          text: `Branch "${branch}" deleted successfully!`,
        },
      ],
    };
  }

  // Collaborators Management Methods
  async addCollaborator(args) {
    const { owner, repo, username, permission = 'push' } = args;
    await this.octokit.rest.repos.addCollaborator({
      owner,
      repo,
      username,
      permission,
    });
    return {
      content: [
        {
          type: 'text',
          text: `Collaborator "${username}" added successfully with "${permission}" permission!`,
        },
      ],
    };
  }

  async listCollaborators(args) {
    const { owner, repo, affiliation = 'all', per_page = 30 } = args;
    const response = await this.octokit.rest.repos.listCollaborators({
      owner,
      repo,
      affiliation,
      per_page,
    });
    
    const collaborators = response.data.map(collab => 
      `â€¢ ${collab.login} (${collab.permissions.admin ? 'Admin' : collab.permissions.push ? 'Push' : 'Pull'})`
    ).join('\n');
    
    return {
      content: [
        {
          type: 'text',
          text: `Found ${response.data.length} collaborators:\n${collaborators}`,
        },
      ],
    };
  }

  async removeCollaborator(args) {
    const { owner, repo, username } = args;
    await this.octokit.rest.repos.removeCollaborator({
      owner,
      repo,
      username,
    });
    return {
      content: [
        {
          type: 'text',
          text: `Collaborator "${username}" removed successfully!`,
        },
      ],
    };
  }

  // Releases Management Methods
  async createRelease(args) {
    const { owner, repo, tag_name, target_commitish = 'main', name, body, draft = false, prerelease = false } = args;
    const releaseData = { owner, repo, tag_name, target_commitish, draft, prerelease };
    
    if (name) releaseData.name = name;
    if (body) releaseData.body = body;
    
    const response = await this.octokit.rest.repos.createRelease(releaseData);
    return {
      content: [
        {
          type: 'text',
          text: `Release created successfully!\nTag: ${tag_name}\nName: ${name || tag_name}\nURL: ${response.data.html_url}`,
        },
      ],
    };
  }

  async listReleases(args) {
    const { owner, repo, per_page = 30 } = args;
    const response = await this.octokit.rest.repos.listReleases({
      owner,
      repo,
      per_page,
    });
    
    const releases = response.data.map(release => 
      `â€¢ ${release.tag_name}: ${release.name || 'No name'} (${release.draft ? 'Draft' : release.prerelease ? 'Prerelease' : 'Release'})`
    ).join('\n');
    
    return {
      content: [
        {
          type: 'text',
          text: `Found ${response.data.length} releases:\n${releases}`,
        },
      ],
    };
  }

  // Search Methods
  async searchRepositories(args) {
    const { query, sort = 'stars', order = 'desc', per_page = 30 } = args;
    const response = await this.octokit.rest.search.repos({
      q: query,
      sort,
      order,
      per_page,
    });
    
    const repos = response.data.items.map(repo => 
      `â€¢ ${repo.full_name} (${repo.stargazers_count} stars) - ${repo.description || 'No description'}`
    ).join('\n');
    
    return {
      content: [
        {
          type: 'text',
          text: `Found ${response.data.total_count} repositories:\n${repos}`,
        },
      ],
    };
  }

  async searchIssues(args) {
    const { query, sort = 'created', order = 'desc', per_page = 30 } = args;
    const response = await this.octokit.rest.search.issuesAndPullRequests({
      q: query,
      sort,
      order,
      per_page,
    });
    
    const issues = response.data.items.map(issue => 
      `â€¢ ${issue.repository.full_name}#${issue.number}: ${issue.title} (${issue.state})`
    ).join('\n');
    
    return {
      content: [
        {
          type: 'text',
          text: `Found ${response.data.total_count} issues:\n${issues}`,
        },
      ],
    };
  }

  async searchCode(args) {
    const { query, sort = 'indexed', order = 'desc', per_page = 30 } = args;
    const response = await this.octokit.rest.search.code({
      q: query,
      sort,
      order,
      per_page,
    });
    
    const codeResults = response.data.items.map(item => 
      `â€¢ ${item.repository.full_name}: ${item.path}`
    ).join('\n');
    
    return {
      content: [
        {
          type: 'text',
          text: `Found ${response.data.total_count} code results:\n${codeResults}`,
        },
      ],
    };
  }

  // User Management Methods
  async getUser(args) {
    const { username } = args;
    const response = await this.octokit.rest.users.getByUsername({ username });
    return {
      content: [
        {
          type: 'text',
          text: `User: ${response.data.login}\nName: ${response.data.name || 'No name'}\nBio: ${response.data.bio || 'No bio'}\nPublic Repos: ${response.data.public_repos}\nFollowers: ${response.data.followers}\nFollowing: ${response.data.following}\nURL: ${response.data.html_url}`,
        },
      ],
    };
  }

  async getAuthenticatedUser(args) {
    const response = await this.octokit.rest.users.getAuthenticated();
    return {
      content: [
        {
          type: 'text',
          text: `Authenticated User: ${response.data.login}\nName: ${response.data.name || 'No name'}\nEmail: ${response.data.email || 'No email'}\nPublic Repos: ${response.data.public_repos}\nPrivate Repos: ${response.data.total_private_repos}\nURL: ${response.data.html_url}`,
        },
      ],
    };
  }

  async run() {
    const transport = new StdioServerTransport();
    await this.server.connect(transport);
    console.error('GitHub MCP server running on stdio');
  }
}

const server = new GitHubMCPServer();
server.run().catch(console.error);










